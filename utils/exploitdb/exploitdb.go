package exploitdb

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
)

type ExploitDB struct{}

// {"draw":0,"recordsTotal":0,"recordsFiltered":0,"data":[],"0":"tags","1":"code","2":"author:id,name","3":"type","4":"platform"}
type CVEResponse struct {
	RecordsTotal uint32 `json:"recordsTotal"`
	Data         []struct {
		ID          string   `json:"id"`
		Description []string `json:"description"`
	} `json:"data"`
}

func New() *ExploitDB {
	return new(ExploitDB)
}

func (e *ExploitDB) Start(cve string, verbose bool) {
	var (
		client   *http.Client
		resp     *http.Response
		err      error
		body     []byte
		response CVEResponse
		results  []string
	)
	client = new(http.Client)
	query := strings.Split(strings.ToLower(cve), "cve-")[1]
	url := fmt.Sprintf("https://www.exploit-db.com/search?cve=%s", query)
	if verbose {
		log.Printf("Requesting %s\n", url)
	}
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("User-Agent", "CVESearch")
	req.Header.Set("X-Requested-With", "XMLHttpRequest")
	if resp, err = client.Do(req); err != nil {
		log.Fatal(err)
	}

	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	resp.Body.Close()

	if err := json.Unmarshal(body, &response); err != nil {
		log.Fatal(err)
	}
	if verbose {
		log.Printf("Found %d results in the ExploitDB\n", response.RecordsTotal)
	}
	for i := 0; i < int(response.RecordsTotal); i++ {
		result := fmt.Sprintf("%s - https://www.exploit-db.com/exploits/%s", response.Data[i].Description[1], response.Data[i].ID)
		results = append(results, result)
	}

	e.prettyPrint(results)
}

func (e *ExploitDB) prettyPrint(results []string) {
	if len(results) == 0 {
		log.Println("No results found on ExploitDB")
		return
	}
	for _, result := range results {
		fmt.Printf("%s\n", result)
	}
}
